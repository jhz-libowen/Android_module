package com.example.libowen.fabo_android.RadarAnimation;import android.content.Context;import android.graphics.Canvas;import android.graphics.Paint;import android.graphics.RectF;import android.support.annotation.Nullable;import android.util.AttributeSet;import android.view.View;import android.view.animation.Interpolator;import android.view.animation.LinearInterpolator;import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * Created by libowen on 2018/2/6. * <com.example.libowen.fabo_android.RadarAnimation.RadarView android:id="@+id/radar_view" android:layout_width="match_parent" android:layout_height="match_parent" /> RadarView radarView = (RadarView) findViewById(R.id.radar_view); radarView.setStrokeWith(10); radarView.setDuration(5000); radarView.setStyle(Paint.Style.STROKE); radarView.setSpeed(400); radarView.setColor(Color.parseColor("#ff0000")); radarView.setInterpolator(new AccelerateInterpolator(1.2f)); radarView.start(); */public class RadarView extends View {    private float mInitialRadius; //初始波纹半径    private float mMaxRadius;    private long mDuration = 2000; //波纹从创建到消失的时间    private int mSpeed = 500;    private float mMaxRadiusRate = 0.85f;    private boolean mMaxRadiusSet;    private float mStrokeWith = 10.0f;    private boolean mIsRunning;    private long mLastCreateTime;    private List<Circle> mCircleList = new ArrayList<>();    private Runnable mCreateCircle = new Runnable() {        @Override        public void run() {            if (mIsRunning) {                newCircle();                postDelayed(mCreateCircle, mSpeed);            }        }    };    private Interpolator mInterpolator = new LinearInterpolator();    private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);    public RadarView(Context context) {        super(context);    }    public RadarView(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);    }    public void setStyle(Paint.Style style) {        mPaint.setStyle(style);    }    @Override    protected void onSizeChanged(int w, int h, int oldw, int oldh) {        if (!mMaxRadiusSet) {            mMaxRadius = Math.min(w, h) * mMaxRadiusRate / 2.0f;        }    }    /**     * 开始     */    public void start() {        if (!mIsRunning) {            mIsRunning = true;            mCreateCircle.run();        }    }    /**     * 缓慢停止     */    public void stop() {        mIsRunning = false;    }    /**     * 立即停止     */    public void stopImmediately() {        mIsRunning = false;        mCircleList.clear();        invalidate();    }    /**     * Iterator 迭代器     *     * @param canvas     */    @Override    protected void onDraw(Canvas canvas) {        Iterator<Circle> iterator = mCircleList.iterator();        while (iterator.hasNext()) {            Circle circle = iterator.next();            float radius = circle.getCurrentRadius();            if (System.currentTimeMillis() - circle.mCreateTime < mDuration) {                mPaint.setAlpha(circle.getAlpha());                mPaint.setStrokeWidth(mStrokeWith);//                canvas.drawCircle(getWidth() / 2, getHeight() / 2, radius, mPaint);   // 画圆                RectF rectF = new RectF();                rectF.set(getWidth() / 2 - radius, getHeight() / 2 - radius, getWidth() / 2 + radius, getHeight() / 2 + radius);                if (radius < 10) {                    mPaint.setStrokeWidth(radius);                }                canvas.drawArc(rectF, 225.0f, 90.0f, false, mPaint);            } else {                iterator.remove();            }        }        if (mCircleList.size() > 0) {            postInvalidateDelayed(10);        }    }    public void setStrokeWith(float with) {        mStrokeWith = with;    }    public void setInitialRadius(float radius) {        mInitialRadius = radius;    }    public void setDuration(long duration) {        mDuration = duration;    }    public void setMaxRadius(float maxRadius) {        mMaxRadius = maxRadius;        mMaxRadiusSet = true;    }    public void setSpeed(int speed) {        mSpeed = speed;    }    public void setMaxRadiusRate(float maxRadiusRate) {        mMaxRadiusRate = maxRadiusRate;    }    public void setColor(int color) {        mPaint.setColor(color);    }    public void newCircle() {        long currentTime = System.currentTimeMillis();        if (currentTime - mLastCreateTime < mSpeed) {            return;        }        Circle circle = new Circle();        mCircleList.add(circle);        invalidate();        mLastCreateTime = currentTime;    }    public void setInterpolator(Interpolator interpolator) {        mInterpolator = interpolator;        if (mInterpolator == null) {            mInterpolator = new LinearInterpolator();        }    }    private class Circle {        private long mCreateTime;        public Circle() {            mCreateTime = System.currentTimeMillis();        }        public float getCurrentRadius() {            float percent = (System.currentTimeMillis() - mCreateTime) * 1.0f / mDuration;            return mInitialRadius + mInterpolator.getInterpolation(percent) * (mMaxRadius - mInitialRadius);        }        public int getAlpha() {            float percent = (getCurrentRadius() - mInitialRadius) / (mMaxRadius - mInitialRadius);            return (int) (255 - mInterpolator.getInterpolation(percent) * 255);        }    }}